import * as playback from '../playback';
import * as util from '../util';
import * as spatial from '../spatial';
import * as events from '../events';
import { Rect } from '../spatial';
import { CheapLocator } from './cheaplocator';
import { ExpensiveLocator } from './expensivelocator';
import { Scroller } from './scroller';
// NOTE: At 2px and below, there is some antialiasing issues on higher resolutions. The cursor will appear to "pulse" as
// it moves. This will happen even when rounding the position.
const CURSOR_WIDTH_PX = 3;
export class Cursor {
    scroller;
    states;
    sequence;
    cheapLocator;
    expensiveLocator;
    span;
    topic = new events.Topic();
    index = 0;
    alpha = 0; // interpolation factor, ranging from 0 to 1
    constructor(opts) {
        this.scroller = opts.scroller;
        this.states = opts.states;
        this.sequence = opts.sequence;
        this.cheapLocator = opts.cheapLocator;
        this.expensiveLocator = opts.expensiveLocator;
        this.span = opts.span;
    }
    static create(scrollContainer, score, sequence, span) {
        // NumberRange objects indexed by system index for the part.
        const systemPartYRanges = new Array();
        for (const system of score.getSystems()) {
            const rect = Rect.merge(system
                .getMeasures()
                .flatMap((measure) => measure.getFragments())
                .flatMap((fragment) => fragment.getParts())
                .filter((part) => span.fromPartIndex <= part.getIndex() && part.getIndex() <= span.toPartIndex)
                .map((part) => part.rect()));
            const yRange = new util.NumberRange(rect.top(), rect.bottom());
            systemPartYRanges.push(yRange);
        }
        const states = new Array(sequence.getCount());
        for (let index = 0; index < sequence.getCount(); index++) {
            const sequenceEntry = sequence.getEntry(index);
            util.assertNotNull(sequenceEntry);
            const hasPrevious = index > 0;
            const hasNext = index < sequence.getCount() - 1;
            const element = sequenceEntry.anchorElement;
            util.assertDefined(element);
            const xRange = sequenceEntry.xRange;
            const systemIndex = element.getSystemIndex();
            const yRange = systemPartYRanges.at(systemIndex);
            util.assertDefined(yRange);
            const x = xRange.start;
            const y = yRange.start;
            const w = CURSOR_WIDTH_PX;
            const h = yRange.getSize();
            const cursorRect = new spatial.Rect(x, y, w, h);
            states[index] = {
                index,
                hasPrevious,
                hasNext,
                cursorRect,
                sequenceEntry,
            };
        }
        const scroller = new Scroller(scrollContainer);
        const cheapLocator = new CheapLocator(sequence);
        const expensiveLocator = new ExpensiveLocator(sequence);
        return new Cursor({
            scroller,
            states,
            sequence,
            cheapLocator,
            expensiveLocator,
            span,
        });
    }
    getState() {
        const state = this.states.at(this.index);
        // TODO: We need a way to represent a zero state, when the sequence validly has no entries. Maybe we update the
        // signature to be nullable.
        util.assertDefined(state);
        if (this.alpha === 0) {
            return { ...state };
        }
        const x = util.lerp(state.sequenceEntry.xRange.start, state.sequenceEntry.xRange.end, this.alpha);
        const y = state.cursorRect.y;
        const w = state.cursorRect.w;
        const h = state.cursorRect.h;
        const cursorRect = new spatial.Rect(x, y, w, h);
        return { ...state, cursorRect };
    }
    next() {
        if (this.index === this.sequence.getCount() - 1) {
            this.update(this.index, 1);
        }
        else {
            this.update(this.index + 1, 0);
        }
    }
    previous() {
        this.update(this.index - 1, 0);
    }
    goTo(index) {
        this.update(index, 0);
    }
    /** Snaps to the closest sequence entry step. */
    snap(timestampMs) {
        timestampMs = util.clamp(0, this.sequence.getDuration().ms, timestampMs);
        const time = playback.Duration.ms(timestampMs);
        const index = this.getIndexClosestTo(time);
        this.update(index, 0);
    }
    /** Seeks to the exact position, interpolating as needed. */
    seek(timestampMs) {
        timestampMs = util.clamp(0, this.sequence.getDuration().ms, timestampMs);
        const time = playback.Duration.ms(timestampMs);
        const index = this.getIndexClosestTo(time);
        const entry = this.sequence.getEntry(index);
        util.assertNotNull(entry);
        const left = entry.durationRange.start;
        const right = entry.durationRange.end;
        const alpha = (time.ms - left.ms) / (right.ms - left.ms);
        this.update(index, alpha);
    }
    isFullyVisible() {
        const cursorRect = this.getState().cursorRect;
        return this.scroller.isFullyVisible(cursorRect);
    }
    scrollIntoView(behavior = 'auto') {
        const scrollPoint = this.getScrollPoint();
        this.scroller.scrollTo(scrollPoint, behavior);
    }
    addEventListener(name, listener, opts) {
        const id = this.topic.subscribe(name, listener);
        if (opts?.emitBootstrapEvent) {
            listener(this.getState());
        }
        return id;
    }
    removeEventListener(...ids) {
        for (const id of ids) {
            this.topic.unsubscribe(id);
        }
    }
    removeAllEventListeners() {
        this.topic.unsubscribeAll();
    }
    getScrollPoint() {
        const cursorRect = this.getState().cursorRect;
        const x = cursorRect.center().x;
        const y = cursorRect.y;
        return new spatial.Point(x, y);
    }
    update(index, alpha) {
        index = util.clamp(0, this.sequence.getCount() - 1, index);
        alpha = util.clamp(0, 1, alpha);
        // Round to 3 decimal places to avoid overloading the event system with redundant updates.
        alpha = Math.round(alpha * 1000) / 1000;
        if (index !== this.index || alpha !== this.alpha) {
            this.index = index;
            this.alpha = alpha;
            this.topic.publish('change', this.getState());
        }
    }
    getIndexClosestTo(time) {
        const index = this.cheapLocator.setStartingIndex(this.index).locate(time) ?? this.expensiveLocator.locate(time);
        if (typeof index !== 'number') {
            throw new Error(`locator coverage is insufficient to locate time ${time.ms}`);
        }
        return index;
    }
}
