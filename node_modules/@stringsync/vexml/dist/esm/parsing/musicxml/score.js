import { System } from './system';
import { IdProvider } from './idprovider';
import { ScoreContext } from './contexts';
export class Score {
    config;
    log;
    idProvider;
    title;
    partLabels;
    systems;
    constructor(config, log, idProvider, title, partLabels, systems) {
        this.config = config;
        this.log = log;
        this.idProvider = idProvider;
        this.title = title;
        this.partLabels = partLabels;
        this.systems = systems;
    }
    static create(config, log, musicXML) {
        const idProvider = new IdProvider();
        const title = musicXML.scorePartwise.getTitle();
        const partLabels = musicXML.scorePartwise.getPartDetails().map((p) => p.name);
        // When parsing, we'll assume that there is only one system. Pre-rendering determines the minimum needed widths for
        // each element. We can then use this information to determine the number of systems needed to fit a constrained
        // width if needed.
        const systems = [System.create(config, log, { scorePartwise: musicXML.scorePartwise })];
        return new Score(config, log, idProvider, title, partLabels, systems);
    }
    parse() {
        const scoreCtx = new ScoreContext(this.idProvider);
        return {
            type: 'score',
            title: this.title,
            partLabels: this.partLabels,
            systems: this.systems.map((s) => s.parse(scoreCtx)),
            curves: scoreCtx.getCurves(),
            wedges: scoreCtx.getWedges(),
            pedals: scoreCtx.getPedals(),
            octaveShifts: scoreCtx.getOctaveShifts(),
            vibratos: scoreCtx.getVibratos(),
        };
    }
}
