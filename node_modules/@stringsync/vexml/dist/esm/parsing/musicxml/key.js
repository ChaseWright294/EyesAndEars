import * as conversions from './conversions';
const CIRCLE_OF_FIFTHS_SHARP = ['F', 'C', 'G', 'D', 'A', 'E', 'B'];
const CIRCLE_OF_FIFTHS_FLAT = ['B', 'E', 'A', 'D', 'G', 'C', 'F'];
/** Represents a key signature. */
export class Key {
    config;
    log;
    partId;
    staveNumber;
    fifths;
    previousKey;
    mode;
    constructor(config, log, partId, staveNumber, fifths, previousKey, mode) {
        this.config = config;
        this.log = log;
        this.partId = partId;
        this.staveNumber = staveNumber;
        this.fifths = fifths;
        this.previousKey = previousKey;
        this.mode = mode;
    }
    static default(config, log, partId, staveNumber) {
        return new Key(config, log, partId, staveNumber, 0, null, 'none');
    }
    static create(config, log, partId, staveNumber, previousKey, musicXML) {
        return new Key(config, log, partId, staveNumber, musicXML.key.getFifthsCount(), previousKey, musicXML.key.getMode());
    }
    parse() {
        return {
            type: 'key',
            fifths: this.fifths,
            mode: this.mode,
            rootNote: this.getRootNote(),
            previousKey: this.parsePreviousKey(),
        };
    }
    getPartId() {
        return this.partId;
    }
    getStaveNumber() {
        return this.staveNumber;
    }
    /** Returns the accidental code being applied to the line that the pitch is on based on the key signature. */
    getAccidentalCode(pitch) {
        // strip the accidental character (e.g., #, b) if any
        const root = pitch.charAt(0);
        const alterations = this.getAlterations();
        if (this.fifths > 0) {
            const sharpCount = Math.min(this.fifths, 7);
            const sharps = CIRCLE_OF_FIFTHS_SHARP.slice(0, sharpCount);
            const sharpIndex = sharps.findIndex((sharp) => sharp === root);
            return sharpIndex < 0 ? 'n' : alterations[sharpIndex] ?? '#';
        }
        if (this.fifths < 0) {
            const flatCount = Math.min(Math.abs(this.fifths), 7);
            const flats = CIRCLE_OF_FIFTHS_FLAT.slice(0, flatCount);
            const flatIndex = flats.findIndex((flat) => flat === root);
            return flatIndex < 0 ? 'n' : alterations[flatIndex] ?? 'b';
        }
        return 'n';
    }
    isEqual(key) {
        return this.partId === key.partId && this.staveNumber === key.staveNumber && this.isEquivalent(key);
    }
    isEquivalent(key) {
        return (this.fifths === key.fifths && this.mode === key.mode && this.arePreviousKeySignaturesEquivalent(key.previousKey));
    }
    arePreviousKeySignaturesEquivalent(previousKey) {
        return this.previousKey?.fifths === previousKey?.fifths && this.previousKey?.mode === previousKey?.mode;
    }
    parsePreviousKey() {
        if (!this.previousKey) {
            return null;
        }
        return {
            type: 'previouskey',
            rootNote: this.previousKey.getRootNote(),
            fifths: this.previousKey.fifths,
            mode: this.previousKey.mode,
        };
    }
    /** Returns the alterations of the  key signature. */
    getAlterations() {
        const alterations = new Array();
        if (Math.abs(this.fifths) > 7) {
            const additional = Math.abs(this.fifths) - 7;
            for (let index = 0; index < additional; index++) {
                alterations.push(this.fifths > 0 ? '##' : 'bb');
            }
        }
        return alterations;
    }
    getRootNote() {
        // Clamp between -7 and 7 â€” the excess gets handled by alterations.
        let fifths = this.fifths;
        fifths = Math.max(-7, fifths);
        fifths = Math.min(7, fifths);
        switch (this.mode) {
            case 'major':
                return conversions.fromFifthsToMajorKey(fifths);
            case 'minor':
                return conversions.fromFifthsToMinorKey(fifths);
            default:
                return conversions.fromFifthsToMajorKey(fifths);
        }
    }
}
