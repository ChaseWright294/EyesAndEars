import * as util from '../../util';
import * as conversions from './conversions';
import { Fraction } from './fraction';
import { Pitch } from './pitch';
import { VoiceEntryContext } from './contexts';
import { Beam } from './beam';
import { Tuplet } from './tuplet';
export class Rest {
    config;
    log;
    measureBeat;
    durationType;
    dotCount;
    duration;
    displayPitch;
    beam;
    tuplets;
    constructor(config, log, measureBeat, durationType, dotCount, duration, displayPitch, beam, tuplets) {
        this.config = config;
        this.log = log;
        this.measureBeat = measureBeat;
        this.durationType = durationType;
        this.dotCount = dotCount;
        this.duration = duration;
        this.displayPitch = displayPitch;
        this.beam = beam;
        this.tuplets = tuplets;
    }
    static create(config, log, measureBeat, duration, musicXML) {
        util.assert(musicXML.note.isRest(), 'Expected note to be a rest');
        const displayStep = musicXML.note.getRestDisplayStep();
        const displayOctave = musicXML.note.getRestDisplayOctave();
        let displayPitch = null;
        if (displayStep && typeof displayOctave === 'number') {
            displayPitch = new Pitch(config, log, displayStep, displayOctave);
        }
        let durationType = conversions.fromNoteTypeToDurationType(musicXML.note.getType());
        let dotCount = musicXML.note.getDotCount();
        if (!durationType) {
            [durationType, dotCount] = conversions.fromFractionToDurationType(duration);
        }
        let beam = null;
        if (musicXML.note.getBeams().length > 0) {
            beam = Beam.create(config, log, { beam: musicXML.note.getBeams().at(0) });
        }
        const tuplets = musicXML.note
            .getNotations()
            .flatMap((n) => n.getTuplets())
            .map((tuplet) => Tuplet.create(config, log, { tuplet }));
        return new Rest(config, log, measureBeat, durationType, dotCount, duration, displayPitch, beam, tuplets);
    }
    static whole(config, log, time) {
        const measureBeat = util.Fraction.zero();
        const duration = time.toFraction().multiply(new util.Fraction(4, 1));
        const [durationType, dotCount] = conversions.fromFractionToDurationType(duration);
        return new Rest(config, log, measureBeat, durationType, dotCount, duration, null, null, []);
    }
    parse(voiceCtx) {
        const voiceEntryCtx = VoiceEntryContext.rest(voiceCtx);
        const tupletIds = util.unique([
            ...this.tuplets.map((tuplet) => tuplet.parse(voiceEntryCtx)).filter((id) => id !== null),
            ...voiceEntryCtx.continueOpenTuplets(),
        ]);
        return {
            type: 'rest',
            durationType: this.durationType,
            dotCount: this.dotCount,
            measureBeat: this.getMeasureBeat().parse(),
            duration: this.getDuration().parse(),
            displayPitch: this.displayPitch?.parse() ?? null,
            beamId: this.beam?.parse(voiceEntryCtx) ?? null,
            pedalMark: voiceEntryCtx.continueOpenPedal(),
            tupletIds,
        };
    }
    getMeasureBeat() {
        return new Fraction(this.measureBeat);
    }
    getDuration() {
        return new Fraction(this.duration);
    }
}
