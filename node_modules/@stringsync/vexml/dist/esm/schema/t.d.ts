export type SchemaType<T> = T extends {
    type: 'string';
    defaultValue: infer D;
} ? string | D : T extends {
    type: 'number';
    defaultValue: infer D;
} ? number | D : T extends {
    type: 'boolean';
    defaultValue: infer D;
} ? boolean | D : T extends {
    type: 'enum';
    choices: Readonly<Array<infer S>>;
    defaultValue: infer D;
} ? S | D : never;
export type SchemaConfig<T extends Record<any, any>> = {
    [K in keyof T]: SchemaType<T[K]>;
};
export type SchemaDescriptor = ReturnType<typeof t.string | typeof t.number | typeof t.boolean | typeof t.enum>;
export type AnySchema = Record<string, SchemaDescriptor>;
/** A class for creating schema types. */
export declare class t {
    static defaultConfig<T extends AnySchema>(schema: T): SchemaConfig<T>;
    static string<D extends string | null>(opts: {
        defaultValue: D;
        help: string;
    }): {
        readonly type: "string";
        readonly defaultValue: D;
        readonly help: string;
    };
    static number<D extends number | null>(opts: {
        defaultValue: D;
        help: string;
    }): {
        readonly type: "number";
        readonly defaultValue: D;
        readonly help: string;
    };
    static boolean<D extends boolean | null>(opts: {
        defaultValue: D;
        help: string;
    }): {
        readonly type: "boolean";
        readonly defaultValue: D;
        readonly help: string;
    };
    static enum<T extends readonly [string, ...string[]], D extends T[number] | null>(opts: {
        choices: T;
        defaultValue: D;
        help: string;
    }): {
        readonly type: "enum";
        readonly choices: T;
        readonly defaultValue: D;
        readonly help: string;
    };
    private constructor();
}
