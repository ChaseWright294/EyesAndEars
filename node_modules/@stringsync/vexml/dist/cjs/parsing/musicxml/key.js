"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.Key = void 0;
const conversions = __importStar(require("./conversions"));
const CIRCLE_OF_FIFTHS_SHARP = ['F', 'C', 'G', 'D', 'A', 'E', 'B'];
const CIRCLE_OF_FIFTHS_FLAT = ['B', 'E', 'A', 'D', 'G', 'C', 'F'];
/** Represents a key signature. */
class Key {
    config;
    log;
    partId;
    staveNumber;
    fifths;
    previousKey;
    mode;
    constructor(config, log, partId, staveNumber, fifths, previousKey, mode) {
        this.config = config;
        this.log = log;
        this.partId = partId;
        this.staveNumber = staveNumber;
        this.fifths = fifths;
        this.previousKey = previousKey;
        this.mode = mode;
    }
    static default(config, log, partId, staveNumber) {
        return new Key(config, log, partId, staveNumber, 0, null, 'none');
    }
    static create(config, log, partId, staveNumber, previousKey, musicXML) {
        return new Key(config, log, partId, staveNumber, musicXML.key.getFifthsCount(), previousKey, musicXML.key.getMode());
    }
    parse() {
        return {
            type: 'key',
            fifths: this.fifths,
            mode: this.mode,
            rootNote: this.getRootNote(),
            previousKey: this.parsePreviousKey(),
        };
    }
    getPartId() {
        return this.partId;
    }
    getStaveNumber() {
        return this.staveNumber;
    }
    /** Returns the accidental code being applied to the line that the pitch is on based on the key signature. */
    getAccidentalCode(pitch) {
        // strip the accidental character (e.g., #, b) if any
        const root = pitch.charAt(0);
        const alterations = this.getAlterations();
        if (this.fifths > 0) {
            const sharpCount = Math.min(this.fifths, 7);
            const sharps = CIRCLE_OF_FIFTHS_SHARP.slice(0, sharpCount);
            const sharpIndex = sharps.findIndex((sharp) => sharp === root);
            return sharpIndex < 0 ? 'n' : alterations[sharpIndex] ?? '#';
        }
        if (this.fifths < 0) {
            const flatCount = Math.min(Math.abs(this.fifths), 7);
            const flats = CIRCLE_OF_FIFTHS_FLAT.slice(0, flatCount);
            const flatIndex = flats.findIndex((flat) => flat === root);
            return flatIndex < 0 ? 'n' : alterations[flatIndex] ?? 'b';
        }
        return 'n';
    }
    isEqual(key) {
        return this.partId === key.partId && this.staveNumber === key.staveNumber && this.isEquivalent(key);
    }
    isEquivalent(key) {
        return (this.fifths === key.fifths && this.mode === key.mode && this.arePreviousKeySignaturesEquivalent(key.previousKey));
    }
    arePreviousKeySignaturesEquivalent(previousKey) {
        return this.previousKey?.fifths === previousKey?.fifths && this.previousKey?.mode === previousKey?.mode;
    }
    parsePreviousKey() {
        if (!this.previousKey) {
            return null;
        }
        return {
            type: 'previouskey',
            rootNote: this.previousKey.getRootNote(),
            fifths: this.previousKey.fifths,
            mode: this.previousKey.mode,
        };
    }
    /** Returns the alterations of the  key signature. */
    getAlterations() {
        const alterations = new Array();
        if (Math.abs(this.fifths) > 7) {
            const additional = Math.abs(this.fifths) - 7;
            for (let index = 0; index < additional; index++) {
                alterations.push(this.fifths > 0 ? '##' : 'bb');
            }
        }
        return alterations;
    }
    getRootNote() {
        // Clamp between -7 and 7 â€” the excess gets handled by alterations.
        let fifths = this.fifths;
        fifths = Math.max(-7, fifths);
        fifths = Math.min(7, fifths);
        switch (this.mode) {
            case 'major':
                return conversions.fromFifthsToMajorKey(fifths);
            case 'minor':
                return conversions.fromFifthsToMinorKey(fifths);
            default:
                return conversions.fromFifthsToMajorKey(fifths);
        }
    }
}
exports.Key = Key;
