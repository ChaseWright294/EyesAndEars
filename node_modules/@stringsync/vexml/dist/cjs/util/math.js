"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.lerp = exports.lcm = exports.gcd = exports.sum = exports.clamp = exports.min = exports.max = void 0;
/** A slightly more readable version of Math.max that ignores NaN values. */
const max = (values, initial = 0) => {
    return Math.max(initial, ...values.filter((value) => !Number.isNaN(value)));
};
exports.max = max;
/** A slightly more readable version of Math.min that ignores NaN values. */
const min = (values, initial = 0) => {
    return Math.min(initial, ...values.filter((value) => !Number.isNaN(value)));
};
exports.min = min;
/** Ensures a number is within a range. */
const clamp = (min, max, value) => {
    if (Number.isNaN(min) || Number.isNaN(max)) {
        throw new Error('min and max must not be NaN');
    }
    if (min > max) {
        throw new Error('min must be <= max');
    }
    value = Number.isNaN(value) ? min : value;
    return Math.min(max, Math.max(min, value));
};
exports.clamp = clamp;
/** Computes the sum of the numbers, filtering out NaNs. */
const sum = (values, initial = 0) => {
    return values.filter((value) => !Number.isNaN(value)).reduce((sum, value) => sum + value, initial);
};
exports.sum = sum;
/** Returns the greatest common denominator. */
const gcd = (a, b) => {
    return b ? (0, exports.gcd)(b, a % b) : a;
};
exports.gcd = gcd;
/** Returns the least common mulitple between the numbers. */
const lcm = (a, b) => {
    return (a * b) / (0, exports.gcd)(a, b);
};
exports.lcm = lcm;
/** Interpolates between a and b. */
const lerp = (a, b, alpha) => {
    alpha = (0, exports.clamp)(0, 1, alpha);
    return a + (b - a) * alpha;
};
exports.lerp = lerp;
