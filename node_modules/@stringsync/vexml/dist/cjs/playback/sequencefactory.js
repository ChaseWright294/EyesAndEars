"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.SequenceFactory = void 0;
const util = __importStar(require("../util"));
const util_1 = require("../util");
const duration_1 = require("./duration");
const sequence_1 = require("./sequence");
const durationrange_1 = require("./durationrange");
const measuresequenceiterator_1 = require("./measuresequenceiterator");
const LAST_SYSTEM_MEASURE_X_RANGE_PADDING_RIGHT = 10;
class SequenceFactory {
    log;
    score;
    constructor(log, score) {
        this.log = log;
        this.score = score;
    }
    create() {
        const sequences = new Array();
        const partCount = this.score.getPartCount();
        for (let partIndex = 0; partIndex < partCount; partIndex++) {
            const events = this.getSequenceEvents(partIndex);
            const entries = this.toSequenceEntries(events);
            const sequence = new sequence_1.Sequence(partIndex, entries);
            sequences.push(sequence);
        }
        return sequences;
    }
    getSequenceEvents(partIndex) {
        const events = new Array();
        const measures = this.score.getMeasures().map((measure, index) => ({
            index,
            value: measure,
            fragments: measure.getFragments(),
            jumps: measure.getJumps(),
        }));
        const iterator = new measuresequenceiterator_1.MeasureSequenceIterator(measures);
        let measureStartTime = duration_1.Duration.zero();
        for (const measureIndex of iterator) {
            const measure = measures[measureIndex];
            let nextMeasureStartTime = measureStartTime;
            if (measure.value.isMultiMeasure()) {
                const start = measureStartTime;
                const bpm = measure.value.getBpm();
                const duration = duration_1.Duration.minutes(measure.value.getBeatCount().toDecimal() / bpm);
                const stop = start.add(duration);
                events.push({ type: 'start', time: start, element: measure.value });
                events.push({ type: 'stop', time: stop, element: measure.value });
                // measureStartTime, not nextMeasureStartTime!
                measureStartTime = stop;
                continue;
            }
            for (const fragment of measure.fragments) {
                if (fragment.isNonMusicalGap()) {
                    const start = measureStartTime;
                    const duration = duration_1.Duration.ms(fragment.getNonMusicalDurationMs());
                    const stop = start.add(duration);
                    events.push({ type: 'start', time: start, element: fragment });
                    events.push({ type: 'stop', time: stop, element: fragment });
                    nextMeasureStartTime = stop;
                    continue;
                }
                const voiceEntries = fragment
                    .getParts()
                    .filter((part) => part.getIndex() === partIndex)
                    .flatMap((fragmentPart) => fragmentPart.getStaves())
                    .flatMap((stave) => stave.getVoices())
                    .flatMap((voice) => voice.getEntries());
                const bpm = fragment.getBpm();
                for (const voiceEntry of voiceEntries) {
                    // NOTE: getStartMeasureBeat() is relative to the start of the measure.
                    const start = measureStartTime.add(duration_1.Duration.minutes(voiceEntry.getStartMeasureBeat().toDecimal() / bpm));
                    const duration = duration_1.Duration.minutes(voiceEntry.getBeatCount().toDecimal() / bpm);
                    const stop = start.add(duration);
                    events.push({ type: 'start', time: start, element: voiceEntry });
                    events.push({ type: 'stop', time: stop, element: voiceEntry });
                    if (stop.isGreaterThan(nextMeasureStartTime)) {
                        nextMeasureStartTime = stop;
                    }
                }
            }
            measureStartTime = nextMeasureStartTime;
        }
        return events.sort((a, b) => {
            if (a.time.ms !== b.time.ms) {
                return a.time.ms - b.time.ms;
            }
            if (a.type !== b.type) {
                // Stop events should come before start events.
                return a.type === 'stop' ? -1 : 1;
            }
            // If two events occur at the same time and have the same type, sort by x-coordinate.
            return a.element.rect().center().x - b.element.rect().center().x;
        });
    }
    toSequenceEntries(events) {
        const measures = this.score.getMeasures();
        const builder = new SequenceEntryBuilder(this.log, measures);
        for (const event of events) {
            builder.add(event);
        }
        return builder.build();
    }
}
exports.SequenceFactory = SequenceFactory;
/** SequenceEntryBuilder incrementally transforms SequenceEvents to SequenceEntries. */
class SequenceEntryBuilder {
    log;
    measures;
    entries = new Array();
    anchor = null;
    active = new Array();
    pending = new Array();
    x = -1;
    t = duration_1.Duration.ms(-1);
    built = false;
    constructor(log, measures) {
        this.log = log;
        this.measures = measures;
    }
    add(event) {
        if (event.type === 'start') {
            this.start(event);
        }
        else {
            this.stop(event);
        }
    }
    build() {
        util.assert(!this.built, 'SequenceEntryBuilder has already built');
        if (this.anchor && this.pending.length > 0) {
            // We account for the last stop event by using the time of the last entry as a start bound.
            const event = this.pending.at(-1);
            const x1 = this.x;
            const x2 = this.getMeasureRightBoundaryX(event.element);
            const t1 = this.t;
            const t2 = event.time;
            this.push(x1, x2, t1, t2, this.anchor, this.active);
        }
        this.built = true;
        return this.entries;
    }
    start(event) {
        if (this.anchor) {
            const instruction = this.getXRangeInstruction(this.anchor, event.element);
            if (instruction === 'anchor-to-next-event') {
                let x1 = this.x;
                const x2 = this.getLeftBoundaryX(event.element);
                const t1 = this.t;
                const t2 = event.time;
                if (x1 > x2) {
                    // See https://github.com/stringsync/vexml/issues/264 for context.
                    this.log.warn('encountered a sequence-building issue where x1 > x2, forcing a fix', {
                        x1,
                        x2,
                        x: this.x,
                        absoluteMeasureIndex: event.element.getAbsoluteMeasureIndex(),
                    });
                    x1 = this.anchor.rect().center().x;
                }
                this.processPending(new util_1.NumberRange(x1, x2), t1);
                this.active.push(event.element);
                this.push(x1, x2, t1, t2, this.anchor, this.active);
                this.x = x2;
                this.t = t2;
            }
            else if (instruction === 'terminate-to-measure-end-and-reanchor') {
                const x1 = this.x;
                const x2 = this.getMeasureRightBoundaryX(this.anchor);
                const t1 = this.t;
                const t2 = event.time;
                this.processPending(new util_1.NumberRange(x1, x2), t1);
                this.active.push(event.element);
                this.push(x1, x2, t1, t2, this.anchor, this.active);
                this.x = this.getLeftBoundaryX(event.element);
                this.t = t2;
            }
            else if (instruction === 'defer-for-interpolation') {
                this.pending.push(event);
            }
            else if (instruction === 'ignore') {
                // noop
            }
            else if (instruction === 'activate-only') {
                this.entries.at(-1)?.activeElements.push(event.element);
                this.active.push(event.element);
            }
            else {
                util.assertUnreachable();
            }
        }
        else {
            this.x = this.getLeftBoundaryX(event.element);
            this.t = event.time;
        }
        this.anchor = event.element;
    }
    stop(event) {
        // A stop event does not provide a closing x-range boundary, so we don't know where to terminate the in-flight
        // sequence entry. We'll enqueue it for now, and then process it once we have a start event that can provide the
        // closing x-range boundary.
        this.pending.push(event);
    }
    processPending(xRange, t1) {
        // Now that we have a closing x-range boundary, we can process the pending events that occurred.
        while (this.pending.length > 0) {
            const event = this.pending.shift();
            const alpha = (event.time.ms - t1.ms) / xRange.getSize();
            const x1 = this.x;
            const x2 = util.lerp(xRange.start, xRange.end, alpha);
            // t1 is given
            const t2 = event.time;
            if (event.type === 'start') {
                if (x2 < xRange.end && t2.isLessThan(t1)) {
                    this.push(x1, x2, t1, t2, this.anchor, this.active);
                }
                this.active.push(event.element);
            }
            else {
                if (x2 < xRange.end && t2.isLessThan(t1)) {
                    this.push(x1, x2, t1, t2, this.anchor, this.active);
                }
                this.active.splice(this.active.indexOf(event.element), 1);
            }
            this.x = x2;
        }
    }
    push(x1, x2, t1, t2, anchor, active) {
        const durationRange = new durationrange_1.DurationRange(t1, t2);
        const xRange = new util_1.NumberRange(x1, x2);
        this.entries.push({ durationRange, xRange, anchorElement: anchor, activeElements: [...active] });
    }
    getLeftBoundaryX(element) {
        switch (element.name) {
            case 'fragment':
                return this.getFragmentLeftBoundaryX(element);
            case 'measure':
                return this.getMeasureLeftBoundaryX(element);
            case 'note':
            case 'rest':
                return this.getVoiceEntryBoundaryX(element);
            default:
                util.assertUnreachable();
        }
    }
    getMeasureRightBoundaryX(element) {
        const measure = this.measures.find((measure) => measure.includesAbsoluteMeasureIndex(element.getAbsoluteMeasureIndex()));
        util.assertDefined(measure);
        let result = measure.rect().right();
        if (measure.isLastMeasureInSystem()) {
            result -= LAST_SYSTEM_MEASURE_X_RANGE_PADDING_RIGHT;
        }
        return result;
    }
    getFragmentLeftBoundaryX(fragment) {
        return (fragment
            .getParts()
            .flatMap((part) => part.getStaves())
            .map((stave) => stave.playableRect().left())
            .at(0) ?? fragment.rect().left());
    }
    getMeasureLeftBoundaryX(measure) {
        const fragment = measure.getFragments().at(0);
        if (fragment) {
            return this.getFragmentLeftBoundaryX(fragment);
        }
        return measure.rect().left();
    }
    getVoiceEntryBoundaryX(voiceEntry) {
        return voiceEntry.rect().center().x;
    }
    getXRangeInstruction(previous, current) {
        const systemIndex1 = previous.getSystemIndex();
        const systemIndex2 = current.getSystemIndex();
        const measureIndex1 = previous.getAbsoluteMeasureIndex();
        const measureIndex2 = current.getAbsoluteMeasureIndex();
        const startMeasureBeat1 = previous.getStartMeasureBeat();
        const startMeasureBeat2 = current.getStartMeasureBeat();
        const x1 = previous.rect().center().x;
        const x2 = current.rect().center().x;
        if (x1 === x2) {
            // This is common when a part has multiple staves. When elements have the same x-coordinate, we'll just add the
            // current element to the active list.
            return 'activate-only';
        }
        const isProgressingNormallyInTheSameMeasure = measureIndex1 === measureIndex2 && startMeasureBeat1.isLessThan(startMeasureBeat2);
        const isProgressingNormallyAcrossMeasures = measureIndex1 + 1 === measureIndex2;
        const isProgressingNormally = isProgressingNormallyInTheSameMeasure || isProgressingNormallyAcrossMeasures;
        if (isProgressingNormally && x1 < x2) {
            return 'anchor-to-next-event';
        }
        // Below this point, we need to figure out why this is not progressing normally x1 >= x2.
        if (systemIndex1 < systemIndex2) {
            return 'terminate-to-measure-end-and-reanchor';
        }
        if (measureIndex1 === measureIndex2 && startMeasureBeat1.isGreaterThanOrEqualTo(startMeasureBeat2)) {
            // This is ultimately a formatting issue: the current element is rendered before the previous element, even though
            // the current element is played later. In this case, we'll just ignore it and keep progressing until we can find
            // a valid movement forward.
            return 'defer-for-interpolation';
        }
        if (measureIndex1 > measureIndex2) {
            return 'terminate-to-measure-end-and-reanchor';
        }
        // NOTE: Currently, we cannot detect a valid jump forward _in the same measure_. We consider this exceptionally
        // rare and playback is not support for this case.
        if (measureIndex1 + 1 < measureIndex2) {
            return 'terminate-to-measure-end-and-reanchor';
        }
        // At this point, we're in a non-ideal state that isn't covered by any of the cases above. We'll just ignore it.
        return 'ignore';
    }
}
