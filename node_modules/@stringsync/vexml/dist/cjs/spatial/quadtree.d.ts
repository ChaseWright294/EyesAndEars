import { Point } from './point';
import { Rect } from './rect';
import { Shape } from './types';
/**
 * Represents a QuadTree data structure that can store shapes in a 2D space.
 * @link https://en.wikipedia.org/wiki/Quadtree
 */
export declare class QuadTree<T> {
    private boundary;
    private threshold;
    private entries;
    private northeast;
    private northwest;
    private southeast;
    private southwest;
    /**
     * @param boundary The boundary of the QuadTree.
     * @param threshold The number of entries in a node before it subdivides. A tree's entry size can exceed this.
     */
    constructor(boundary: Rect, threshold: number);
    /**
     * Inserts a shape into the QuadTree.
     * @returns true if the point was successfully inserted, false otherwise.
     */
    insert(shape: Shape, data: T): boolean;
    /** Given a point, returns all the shapes that contain it. */
    query(point: Point): T[];
    /**
     * Returns the max number of entries in any tree node in the quad tree.
     *
     * Callers can use this to approximate the balance of the quad tree. If the tree is relatively balanced, then the max
     * number of entries in any node should be less than or equal to the threshold. If the tree is unbalanced, then the
     * max number of entries in any node will be much greater than the threshold.
     *
     * Balance of the tree indicates its performance. For example, if you insert N points, but the maxTreeEntryCount is N,
     * that suggests the query performance will be O(N). At this extreme, the caller should consider a different threshold
     * or a different data structure.
     */
    getMaxTreeEntryCount(): number;
    /** Returns the boundaries of all the nodes. */
    getBoundaries(): Rect[];
    /** Returns all the entries of all the nodes.  */
    getEntries(): T[];
    private isDivided;
    private subdivide;
}
