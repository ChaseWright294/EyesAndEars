"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.Measure = void 0;
const util = __importStar(require("../util"));
const util_1 = require("../util");
const fragment_1 = require("./fragment");
class Measure {
    config;
    log;
    document;
    measureRender;
    fragments;
    constructor(config, log, document, measureRender, fragments) {
        this.config = config;
        this.log = log;
        this.document = document;
        this.measureRender = measureRender;
        this.fragments = fragments;
    }
    static create(config, log, document, measureRender) {
        const fragments = measureRender.fragmentRenders.map((fragmentRender) => fragment_1.Fragment.create(config, log, document, fragmentRender));
        return new Measure(config, log, document, measureRender, fragments);
    }
    /** The name of the element, which can be used as a type discriminant. */
    name = 'measure';
    /** Returns the bounding box of the element. */
    rect() {
        return this.measureRender.rect;
    }
    /** Returns whether this measure is the last in the system. */
    isLastMeasureInSystem() {
        return this.document.isLastMeasure(this.measureRender.key);
    }
    /** Returns the system index of the measure. */
    getSystemIndex() {
        return this.measureRender.key.systemIndex;
    }
    /** Returns whether the measure is a multimeasure. */
    isMultiMeasure() {
        return this.measureRender.multiRestCount > 1;
    }
    /** Returns the fragments of the measure. */
    getFragments() {
        return this.fragments;
    }
    /** Returns the max number of parts in this score. */
    getPartCount() {
        return Math.max(0, ...this.fragments.map((fragment) => fragment.getPartCount()));
    }
    /** Returns the jumps that occur in this measure. */
    getJumps() {
        return this.measureRender.jumps;
    }
    /** Returns the absolute measure index.  */
    getAbsoluteMeasureIndex() {
        return this.measureRender.absoluteIndex;
    }
    /**
     * Sometimes document measures are folded into one (e.g. multimeasure rest). This method returns the [start, end]
     * _absolute_ index range that the measure covers.
     */
    includesAbsoluteMeasureIndex(absoluteMeasureIndex) {
        const start = this.measureRender.absoluteIndex;
        const multiMeasureCount = this.measureRender.multiRestCount;
        if (multiMeasureCount > 1) {
            return new util.NumberRange(start, start + multiMeasureCount - 1).includes(absoluteMeasureIndex);
        }
        else {
            return new util.NumberRange(start, start).includes(absoluteMeasureIndex);
        }
    }
    /** Always returns zero. This is used for sequencing with other playback elements. */
    getStartMeasureBeat() {
        return util_1.Fraction.zero();
    }
    /** Returns how many beats are in this measure. */
    getBeatCount() {
        const time = this.document
            .getMeasure(this.measureRender.key)
            .fragments.flatMap((fragment) => fragment.parts)
            .flatMap((part) => part.staves)
            .map((stave) => stave.signature.time)
            .at(0);
        if (!time) {
            this.log.warn('could not find time signature for measure', this.measureRender.key);
            return util_1.Fraction.zero();
        }
        const components = time.components.map(util_1.Fraction.fromFractionLike);
        const beatsPerMeasure = util_1.Fraction.sum(...components).multiply(new util_1.Fraction(4));
        const measureCount = Math.max(1, this.measureRender.multiRestCount);
        return beatsPerMeasure.multiply(new util_1.Fraction(measureCount));
    }
    /** Returns the BPM of the measure. */
    getBpm() {
        const bpm = this.fragments.at(0)?.getBpm();
        util.assertDefined(bpm);
        return bpm;
    }
}
exports.Measure = Measure;
