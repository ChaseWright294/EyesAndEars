"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.Measure = void 0;
const util = __importStar(require("../util"));
const attributes_1 = require("./attributes");
const barline_1 = require("./barline");
const util_1 = require("../util");
const note_1 = require("./note");
const print_1 = require("./print");
const backup_1 = require("./backup");
const forward_1 = require("./forward");
const direction_1 = require("./direction");
/**
 * Measure is a basic musical data container that has notes and rests.
 *
 * See https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/measure-partwise/
 */
class Measure {
    element;
    constructor(element) {
        this.element = element;
    }
    // Wether the measure number should appear or not.
    isImplicit() {
        return this.element.attr('implicit').withDefault('no').str() === 'yes';
    }
    /** Returns the measure number or an empty string if missing. */
    getNumber() {
        return this.element.attr('number').withDefault('').str();
    }
    /** Returns the specified measured width in tenths. Defaults to null. */
    getWidth() {
        return this.element.attr('width').int();
    }
    /** Returns the <attributes> element of the measure. */
    getAttributes() {
        return this.element.all('attributes').map((element) => new attributes_1.Attributes(element));
    }
    /** Returns the entries of the measure. */
    getEntries() {
        return this.element.children('attributes', 'note', 'backup', 'forward', 'direction').map((element) => {
            if (element.isNamed('attributes')) {
                return new attributes_1.Attributes(element);
            }
            if (element.isNamed('note')) {
                return new note_1.Note(element);
            }
            if (element.isNamed('backup')) {
                return new backup_1.Backup(element);
            }
            if (element.isNamed('forward')) {
                return new forward_1.Forward(element);
            }
            if (element.isNamed('direction')) {
                return new direction_1.Direction(element);
            }
            throw new Error(`unexpected element: <${element.name}>`);
        });
    }
    /** Returns the barlines of the measure. */
    getBarlines() {
        return this.element.all('barline').map((element) => new barline_1.Barline(element));
    }
    /** Returns the prints of the measure. */
    getPrints() {
        return this.element.all('print').map((element) => new print_1.Print(element));
    }
    /** Returns the ending measure for multi rest measures, or itself otherwise. */
    getEndingMeasure() {
        const multipleRestCount = (0, util_1.max)(this.getAttributes()
            .flatMap((attributes) => attributes.getMeasureStyles())
            .map((measureStyle) => measureStyle.getMultipleRestCount()));
        let measure = this.element;
        for (let index = 1; index < multipleRestCount; index++) {
            // We don't expect the next measure to be null. However, if we do come across a null measure, we fallback to the
            // last non-null measure we came across.
            measure = measure.next('measure') ?? measure;
        }
        return new Measure(measure);
    }
    /**
     * Returns the first sound[tempo] specification in the measure.
     *
     * Technically, this can be specified multiple times per measure, but this is a simplification that covers most music.
     * This is independent of the <metronome> element, which describes how to signal metronome engravings.
     */
    getFirstTempo() {
        return util.first(this.element
            .children('sound')
            .map((sound) => sound.attr('tempo').int())
            .filter((tempo) => typeof tempo === 'number'));
    }
}
exports.Measure = Measure;
