"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DirectionType = void 0;
const coda_1 = require("./coda");
const dynamics_1 = require("./dynamics");
const metronome_1 = require("./metronome");
const octaveshift_1 = require("./octaveshift");
const pedal_1 = require("./pedal");
const rehearsal_1 = require("./rehearsal");
const segno_1 = require("./segno");
const symbolic_1 = require("./symbolic");
const wedge_1 = require("./wedge");
const words_1 = require("./words");
/**
 * Represents the type of direction.
 *
 * See https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/direction-type/.
 */
class DirectionType {
    element;
    constructor(element) {
        this.element = element;
    }
    /** Returns the content of the direction type. */
    getContent() {
        const children = this.element.children();
        const first = children[0];
        if (typeof first === 'undefined') {
            return { type: 'empty' };
        }
        if (first.isNamed('rehearsal')) {
            return {
                type: 'rehearsal',
                rehearsals: children
                    .filter((child) => child.isNamed('rehearsal'))
                    .map((child) => new rehearsal_1.Rehearsal(child)),
            };
        }
        if (first.isNamed('segno')) {
            return {
                type: 'segno',
                segnos: children
                    .filter((child) => child.isNamed('segno'))
                    .map((child) => new segno_1.Segno(child)),
            };
        }
        if (first.isNamed('coda')) {
            return {
                type: 'coda',
                codas: children
                    .filter((child) => child.isNamed('coda'))
                    .map((child) => new coda_1.Coda(child)),
            };
        }
        if (first.isNamed('dynamics')) {
            return {
                type: 'dynamics',
                dynamics: children
                    .filter((child) => child.isNamed('dynamics'))
                    .map((child) => new dynamics_1.Dynamics(child)),
            };
        }
        if (first.isNamed('metronome')) {
            return {
                type: 'metronome',
                metronome: new metronome_1.Metronome(first),
            };
        }
        if (first.isNamed('octave-shift')) {
            return {
                type: 'octaveshift',
                octaveShift: new octaveshift_1.OctaveShift(first),
            };
        }
        if (first.isNamed('wedge')) {
            return {
                type: 'wedge',
                wedge: new wedge_1.Wedge(first),
            };
        }
        if (first.isNamed('pedal')) {
            return {
                type: 'pedal',
                pedal: new pedal_1.Pedal(first),
            };
        }
        if (first.isNamed('words') || first.isNamed('symbol')) {
            return {
                type: 'tokens',
                tokens: children
                    .filter((child) => child.isNamed('words') || child.isNamed('symbol'))
                    .map((child) => (child.isNamed('words') ? new words_1.Words(child) : new symbolic_1.Symbolic(child))),
            };
        }
        return {
            type: 'unsupported',
            tagNames: children.map((child) => child.name),
        };
    }
}
exports.DirectionType = DirectionType;
